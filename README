# K2 Marketing AI (Mäklarassistent)

En Go-baserad grund för att snabbt komma igång med en AI-driven plattform som genererar objektbeskrivningar för fastighetsmäklare. Projektet innehåller:

- HTTP-API i Go (chi) med stöd för in-memory lagring eller PostgreSQL.
- Enkel frontend i HTML/CSS/JS som anropar API:et.
- Grundläggande datamodell för objekt (adress, tonalitet, målgrupp, highlights).

## Snabbstart

1. **Installera Go 1.21+** och klona repot.
2. **Skapa din `config.json`** genom att kopiera `config.example.json` och fylla i värden (Gemini-nyckel, ev. S3/DB):

   ```bash
   cp config.example.json config.json
   # redigera config.json och klistra in dina nycklar
   ```

> Obs! `config.json` är ignorerad av git så att nycklar inte råkar committas.

3. **Kör backend med in-memory lagring** (ingen databas behövs initialt):

   ```bash
   go run ./cmd/api
   ```

4. Öppna `http://localhost:8080` och testa flödet genom formuläret.

> Tips: Om din miljö blockar den publika Go-proxyn, kör `GOPROXY=direct go mod tidy` en gång för att ladda ner moduler och generera `go.sum`.

## Anslut till PostgreSQL

När du har en databas (t.ex. på en VPS):

1. Uppdatera `database_url` i `config.json`, exempel:`"database_url": "postgres://user:password@host:5432/dbname?sslmode=disable"`
2. Kör `go run ./cmd/api`

- Vid start skapas tabellen `listings` automatiskt om den saknas.
- API:t behåller samma kontrakt; frontend listar de senaste objekten (max 50).

### Köra PostgreSQL lokalt (utan VPS)

1. Starta en lokal instans med Docker (standardlösenord `postgres`):

   ```bash
   docker run --name k2-postgres -e POSTGRES_PASSWORD=postgres -p 5432:5432 -d postgres:16
   ```

2. Skapa en tom databas:

   ```bash
   docker exec -it k2-postgres createdb -U postgres k2db
   ```

3. Sätt `database_url` i `config.json` till `postgres://postgres:postgres@localhost:5432/k2db?sslmode=disable` och starta backend med `go run ./cmd/api`.

4. Bekräfta att API:t fungerar:

   ```bash
   curl http://localhost:8080/health
   ```

## API-ändpunkter

- `GET /health` – enkel hälsokontroll.
- `GET /api/listings/` – listar senast skapade objekt.
- `POST /api/listings/` – skapar ett nytt objekt.
- `GET /api/listings/{id}/` – hämtar ett enskilt objekt.
- `POST /api/listings/{id}/sections/{slug}/rewrite` – omskriver en sektion med en instruktion i request body.
- `PATCH /api/listings/{id}/sections/{slug}` – sparar manuellt redigerad titel/innehåll för en sektion.
- `GET /api/listings/{id}/export?format=text|html` – hämtar `full_copy` som ren text (default) eller som enkel HTML.
- `DELETE /api/listings/{id}/sections/{slug}` – tar bort en sektion (sparas i historiken).
- `DELETE /api/listings/{id}/` – raderar ett helt objekt.
- `GET /api/events` – SSE-ström som pushar statusuppdateringar (`status`-event) för alla listings.

Exempelpayload för `POST /api/listings/`:

```json
{
  "address": "Skolgatan 12",
  "tone": "Exklusiv och sofistikerad",
  "target_audience": "Barnfamiljer",
  "highlights": ["Låg avgift", "Balkong i söderläge"],
  "fee": 3200,
  "living_area": 82,
  "rooms": 3.5,
  "instructions": "Betona balkongen och håll tonen varm.",
  "full_copy": "",
  "sections": [
    {"slug": "intro", "title": "Inledning", "content": "Inledningstext..."}
  ]
}
```

## Bilduppladdning via S3

Formuläret i webben stöder nu `multipart/form-data` med fältet `photo`. Om en S3-konfiguration finns laddas filen (max 5 MB, jpg/png) upp till bucketen och URL:en sparas på respektive listing. Saknas S3-uppgifter skrivs filen istället till ett temporärt lokalt katalog (`/tmp`) och raderas manuellt efter att du använt den för analys.

Aktivera genom att sätta följande nycklar i `config.json`:

| Variabel | Beskrivning |
| --- | --- |
| `media.bucket` | Namnet på bucketen där bilderna ska sparas (obligatorisk) |
| `media.region` | AWS-region (obligatorisk) |
| `media.key_prefix` | (Valfri) mapp-prefix, t.ex. `uploads/listings` |
| `media.public_url` | (Valfri) Publik bas-URL/CNAME om du serverar via CloudFront el. liknande |
| `media.endpoint` | (Valfri) Eget endpoint för S3-kompatibel lagring, används ihop med `media.force_path_style=true` för t.ex. MinIO/Wasabi |
| `media.force_path_style` | Sätt till `true` om din endpoint kräver path-style URL:er |
| `media.access_key_id` | (Valfri) AWS Access Key ID. Lämna tomt om du använder instans-/rollbaserade credentials |
| `media.secret_access_key` | (Valfri) AWS Secret Access Key |
| `media.session_token` | (Valfri) Session token om du använder tillfälliga credentials |

> Tips: Om du kör lokalt mot MinIO kan du sätta `S3_ENDPOINT=http://localhost:9000`, `S3_FORCE_PATH_STYLE=true` och `S3_PUBLIC_URL=http://localhost:9000/<bucket>` för att kunna förhandsgranska bilderna.

Behöver du bara temporär lagring (t.ex. för bildanalys) kan du hoppa över S3-variablerna. Backend sparar då filen lokalt och visar ingen bild-URL i UI:t.

Om `S3_BUCKET` eller `S3_REGION` utelämnas faller uppladdningar tillbaka till ett inaktiverat läge och backend returnerar ett tydligt fel när en bild skickas med.

> När en bild finns på ett objekt och en Gemini-nyckel är konfigurerad kör backend automatiskt Google AI bildanalys. Resultatet (sammanfattning, rumstyp, stil, färger m.m.) sparas i `insights.vision` och pipeline-steget “Vision” markeras när analysen är klar.

### Bildstudio (friliggande verktyg)

- `POST /api/vision/analyze` – analysera valfri bild-URL **eller** ladda upp en bildfil och få samma strukturerade resultat som i listings.
- `POST /api/vision/design` – lämna textinstruktioner (t.ex. ”Brun lädersoffa, låg tv-bänk i ek...”) och få ett komplett designförslag (layout, möbler, färger, belysning).

I webbgränssnittet finns fliken **Bildstudio** där båda funktionerna finns med formulär och resultatpaneler.

Design-kortet erbjuder nu en enkel “före/efter”-upplevelse: ladda upp en tom rum-bild, välj förinställd känsla (lyxigt, varmt, minimalistiskt…) och lägg till egna instruktioner som “sätt in en king size-säng med tavlor ovanför”. Appen analyserar bilden automagiskt och använder den plus din stil för att generera ett färdigt möbleringsförslag med möbler, färger, belysning och dekor. När du är nöjd klickar du på **Generera bild** så renderas en fotorealistisk mockup via Google Gemini och visas direkt i panelen.

Generator-flödet laddar nu upp dina egna bilder direkt till S3 och sparar dem på objektet (första bilden blir omslagsbilden i listan). I Bildstudion kan du dessutom koppla en genererad bild till valfritt objekt – ett klick laddar upp renderingen till samma bucket och lägger den i objektets galleri.

## Modulär text & geodata

Backend skapar nu strukturerade sektioner (Inledning, Hall, Kök, Vardagsrum, Område) för varje objekt. Frontend visar dessa sektioner i respektive kort och du kan omskriva dem direkt via “Skriv om”-knappen som anropar `POST /api/listings/{id}/sections/{slug}/rewrite`.

Varje sektion har även snabbkommandon (chips) med vanliga promptar – ett klick skickar en färdig instruktion så mäklaren slipper skriva själv. Alla sektioner sammanfogas automatiskt till `full_copy`, som visas i “Samlad text”-rutan och kan kopieras/exporteras.

Sektionerna är flexibla: ange en valfri array i `sections` när du skapar en listing, eller lägg till/ta bort dem direkt i UI:t (lägg till-knappen genererar nya block, papperskorgen tar bort). Geodata samlas nu in per kategori (matbutiker, restauranger, park, gym, transit) och sammanfattas i området-sektionen i stället för en rå lista. Statuspanelen i detaljvyn visar pipeline-steg (Datainsamling, Bildunderlag, Geodata, Text) baserat på backend-fältet `status`. Knappfältet erbjuder:

- `Kopiera text` – ren text (`full_copy`)

- `Kopiera text` – ren text (`full_copy`)
- `Exportera HTML` – samma text som `<p>`-block (Hemnet/portaler)
- `Ladda ner TXT` – sparar en `.txt`-fil lokalt

Historik per sektion (`section_history`) sparas automatiskt (max 5 versioner) varje gång AI eller manuell redigering körs, och mäklaren kan återställa en tidigare version med ett klick.

> Promptmotorn för Gemini är uppstyrd med tydliga sektioninstruktioner och exempelstil, så att texterna följer professionell mäklar-copy snarare än generiska utsagor.

Generering sker via Google Gemini (Generative Language API) när `config.json` innehåller:

```json
"ai": {
  "provider": "gemini",
  "gemini": {
    "api_key": "DIN-GEMINI-NYCKEL",
    "model": "gemini-1.5-pro-latest",
    "vision_model": "gemini-1.5-flash-001",
    "image_model": "gemini-2.5-flash-image",
    "timeout_seconds": 60
  },
  "imagen": {
    "enabled": true,
    "project_id": "DITT-PROJEKT-ID",
    "location": "us-central1",
    "model": "image-generation@006",
    "service_account": "/path/till/service-account.json (valfri om du använder API-nyckel)"
  }
}
```

`vision_model` styr bildanalysen och `image_model` används för Geminis text-baserade render. För exakt foto-redigering använder vi Vertex Imagen (`ai.imagen`). Sätt `enabled` till `true` när du vill aktivera den vägen och ange därefter ditt GCP-projekt, placering (oftast `us-central1`) samt modellen `image-generation@006`. Har du inget service-konto kan samma API-nyckel som för Gemini användas; annars pekar du ut JSON-filen via `service_account`. `timeout_seconds` går att tweaka om du behöver längre (eller kortare) väntetid för anropen; standarden är 60 sekunder.

Geodata hämtas via Google Geocoding + Places. Lägg nyckeln i `config.json`:

| Variabel | Beskrivning |
| --- | --- |
| `geodata.google_places_api_key` | API-nyckel för Geocoding + Places |
| `geodata.trafiklab_api_key` | Nyckel för Trafiklab/Resrobot |
| `geodata.cache_ttl_minutes` | (Valfri) cache-TTL för Places-resultat, default 30 |

Utvecklingsläge: om nyckeln saknas faller providern tillbaka till statiska exempel.

## Nästa steg

- Lägg till automatisk bildanalys (Gemini eller Google Cloud Vision) ovanpå den nya S3-uppladdningen.
- Lägg till geodata (Google Places, Trafiklab) och injicera i textgenereringen.
- Bygg modulär texteditor med sektioner (Inledning, Hall, Kök, Område) och omskrivningar per sektion.
- Lägg till autentisering och rollhantering för mäklarbyråer.

## Utvecklingsnotiser

- Kodstil: standard Go-format (`go fmt ./...`).
- Frontend: vanilla HTML/CSS/JS för enkelhet; byt gärna till React/Svelte när behovet växer.

## Kubernetes & Argo CD

Repo:t innehåller nu en Dockerfile samt manifest under `deploy/`. Flödet ser ut så här i korthet:

1. Bygg och pusha en bild (`Dockerfile`).
2. Skapa en `config.json` för produktion och lägg den i ett K8s-Secret (`k2marketing-config`), t.ex. `kubectl -n k2marketing create secret generic k2marketing-config --from-file=config.json=config.prod.json`.
3. Anpassa `deploy/k8s/overlays/prod/kustomization.yaml` med rätt bildtagg/domän och applicera med `kustomize build ... | kubectl apply -f -`, eller låt Argo CD läsa `deploy/argocd/application.yaml`.

Se `deploy/README.md` för mer detaljer (TLS, Argo-flöde, mm).

## Så committar du till `main`

1. Kontrollera status:

   ```bash
   git status
   ```

2. Lägg till ändringar:

   ```bash
   git add .
   ```

3. Skriv ett beskrivande commitmeddelande och committa till aktuell branch (`main` om du jobbar där):

   ```bash
   git commit -m "Beskrivande meddelande"
   ```

4. Tryck upp till GitHub (ersätt `origin` om du använder annat remote-namn):

   ```bash
   git push origin main
   ```

Om du arbetar via en feature-branch, skapa en PR mot `main` när pushen är klar.
